<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Luy·ªán N√≥i Ti·∫øng ƒê·ª©c Pro - N√¢ng C·∫•p</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            color: #1c1e21;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align top */
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            width: 100%;
            max-width: 700px;
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 30px;
            text-align: center;
        }
        h1 {
            color: #0d6efd;
            margin-bottom: 25px;
        }
        h2 {
            font-size: 1.2rem;
            color: #495057;
            margin-bottom: 10px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 5px;
        }
        textarea {
            width: 100%;
            box-sizing: border-box;
            padding: 12px;
            border: 1px solid #ced4da;
            border-radius: 8px;
            font-size: 1rem;
            margin-bottom: 10px;
            resize: vertical;
        }
        .controls, .session-controls {
            margin: 15px 0;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 12px;
        }
        button {
            background-color: #0d6efd;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button:hover {
            background-color: #0b5ed7;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        button#record-btn { background-color: #198754; }
        button#record-btn:hover { background-color: #157347; }
        .dialogue-box { margin-top: 20px; padding: 15px; background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 8px; text-align: left; }
        .line { padding: 12px; margin: 8px 0; border-radius: 8px; font-size: 1.1rem; }
        .computer-line { background-color: #e7f3ff; }
        .user-line { background-color: #fff3cd; font-weight: bold; border: 2px dashed #ffc107; }
        .status { margin-top: 20px; font-size: 1.1rem; font-weight: bold; min-height: 50px; padding: 10px; border-radius: 8px;}
        .status.success { color: #146c43; background-color: #d1e7dd; }
        .status.error { color: #b02a37; background-color: #f8d7da; }
        .instructions { font-size: 0.9rem; color: #606770; text-align: left; margin-bottom: 20px; background: #eef; padding: 15px; border-radius: 8px; border-left: 4px solid #0d6efd; }
        #review-area { text-align: left; margin-top: 20px; }
        .review-line { padding: 12px; margin: 8px 0; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; }
        .review-line.computer { background-color: #e7f3ff; }
        .review-line.user { background-color: #d1e7dd; font-weight: 500;}
        .play-recording-btn { background-color: #fd7e14; padding: 6px 12px; font-size: 0.9rem; }
        .play-recording-btn:hover { background-color: #e46e0e; }
        #play-all-btn { background-color: #0dcaf0; }
        #play-all-btn:hover { background-color: #0aa8c2; }
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            text-align: left;
        }
        .difficulty-selection, .custom-feedback-area {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        .difficulty-selection fieldset {
            border: none;
            padding: 0;
            margin: 0;
            display: flex;
            justify-content: space-around;
        }
        .difficulty-selection legend {
            font-weight: bold;
            margin-bottom: 10px;
            width: 100%;
        }
        .feedback-box {
            font-size: 1rem;
            font-weight: normal;
            margin-top: 10px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f8f9fa;
            text-align: left;
            line-height: 1.7;
        }
        .diff-correct { color: #000; }
        .diff-incorrect { color: #dc3545; text-decoration: underline; font-weight: bold; }
        .diff-missing { color: #6c757d; font-style: italic; }
        #score-area {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #ffc107;
            color: #333;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1.2rem;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .auto-record-toggle {
            margin-top: 10px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        /* CSS CHO PH·∫¶N T·∫¢I H·ªòI THO·∫†I */
        #danh-sach-hoi-thoai {
            text-align: left;
            margin-bottom: 25px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        #danh-sach-hoi-thoai h2 {
            margin-top: 0;
            border-bottom: none;
            font-size: 1.1rem;
        }
        .file-button {
            background-color: #0d6efd;
            margin: 5px;
            padding: 8px 15px;
            font-size: 0.9rem;
            text-transform: capitalize;
        }
        .file-button:hover {
            background-color: #0b5ed7;
        }
    </style>
</head>
<body>
    <div id="score-area">ƒêi·ªÉm: 100</div>
    <div class="container">
        <h1>Luy·ªán Giao Ti·∫øp Chuy√™n Nghi·ªáp üöÄ</h1>
        
        <div id="danh-sach-hoi-thoai"></div>
        
        <div id="initial-setup">
            <div class="instructions">
                <strong>H∆∞·ªõng d·∫´n:</strong>
                <ol>
                    <li>Ch·ªçn m·ªôt h·ªôi tho·∫°i c√≥ s·∫µn ·ªü tr√™n ho·∫∑c d√°n h·ªôi tho·∫°i c·ªßa b·∫°n v√†o √¥ b√™n d∆∞·ªõi.</li>
                    <li>Ch·ªçn ƒë·ªô kh√≥ v√† c√°c t√πy ch·ªânh kh√°c.</li>
                    <li>Nh·∫•n <strong>"B·∫Øt ƒê·∫ßu Luy·ªán T·∫≠p"</strong>.</li>
                    <li>·ª®ng d·ª•ng s·∫Ω m·ªü m·ªôt popup Google D·ªãch. Nh·∫•n v√†o bi·ªÉu t∆∞·ª£ng micro v√† n√≥i.</li>
                    <li>Khi b·∫°n n√≥i xong, popup s·∫Ω t·ª± ƒë·ªông ƒë√≥ng v√† k·∫øt qu·∫£ s·∫Ω ƒë∆∞·ª£c ch·∫•m ƒëi·ªÉm.</li>
                </ol>
            </div>

            <div class="settings-grid">
                <div class="difficulty-selection">
                    <fieldset>
                        <legend>Ch·ªçn ƒê·ªô Kh√≥</legend>
                        <div><input type="radio" id="easy" name="difficulty" value="80" checked> <label for="easy">D·ªÖ (80%)</label></div>
                        <div><input type="radio" id="medium" name="difficulty" value="90"> <label for="medium">TB (90%)</label></div>
                        <div><input type="radio" id="hard" name="difficulty" value="100"> <label for="hard">Kh√≥ (100%)</label></div>
                    </fieldset>
                    </div>
                <div class="custom-feedback-area">
                    <textarea id="rewards-input" rows="3" placeholder="Ph·∫ßn th∆∞·ªüng (m·ªói d√≤ng m·ªôt c√¢u)...&#10;L√†m t·ªët l·∫Øm!&#10;Ph√°t √¢m chu·∫©n!">L√†m t·ªët l·∫Øm!&#10;Ph√°t √¢m chu·∫©n!&#10;Tuy·ªát v·ªùi!&#10;B·∫°n th·∫≠t si√™u!</textarea>
                    <textarea id="penalties-input" rows="3" placeholder="H√¨nh ph·∫°t (m·ªói d√≤ng m·ªôt c√¢u)...&#10;C·ªë l√™n n√†o!&#10;Th·ª≠ l·∫°i l·∫ßn n·ªØa nh√©.">C·ªë l√™n n√†o!&#10;Th·ª≠ l·∫°i l·∫ßn n·ªØa nh√©.&#10;ƒê·ª´ng n·∫£n l√≤ng.&#10;S·∫Øp ƒë∆∞·ª£c r·ªìi!</textarea>
                </div>
            </div>

            <div class="settings-grid" style="margin-top: 15px;">
                <div class="custom-feedback-area">
                    <label for="success-audio">√Çm thanh khi th√†nh c√¥ng (.mp3):</label>
                    <input type="file" id="success-audio" accept=".mp3">
                </div>
                <div class="custom-feedback-area">
                    <label for="failure-audio">√Çm thanh khi th·∫•t b·∫°i (.mp3):</label>
                    <input type="file" id="failure-audio" accept=".mp3">
                </div>
            </div>

            <textarea id="dialogue-input" rows="6" placeholder="D√°n h·ªôi tho·∫°i c·ªßa b·∫°n ·ªü ƒë√¢y...&#10;V√≠ d·ª•:&#10;A: Hallo, wie geht's?&#10;B: Mir geht's gut, danke."></textarea>
            
            <div class="controls">
                <button id="load-btn">üöÄ B·∫Øt ƒê·∫ßu Luy·ªán T·∫≠p</button>
                <button id="swap-roles-btn">üîÅ ƒê·ªïi Vai (Hi·ªán t·∫°i: B·∫°n l√† B)</button>
            </div>
        </div>

        <div id="practice-area" class="dialogue-box" style="display: none;">
            <h2>L·ªùi tho·∫°i c·ªßa m√°y:</h2>
            <div id="computer-line" class="line computer-line">...</div>
            <div id="user-line-container">
                 <h2 id="user-line-title">C√¢u c·ªßa b·∫°n:</h2>
                 <div id="user-line" class="line user-line" style="display: none;">...</div>
            </div>
        </div>
        
        <div id="status-area" class="status"></div>
        
        <div id="session-controls-area" style="display: none;">
            <div class="session-controls">
                <button id="record-btn" disabled>üé§ B·∫Øt ƒê·∫ßu Ghi √Çm</button>
                <button id="toggle-line-btn" disabled>üôà Hi·ªán L·ªùi Tho·∫°i</button>
            </div>
        </div>
        
        <div id="review-area" style="display: none;">
            <h2>Xem L·∫°i H·ªôi Tho·∫°i</h2>
            <div id="review-content"></div>
            <div class="controls" style="margin-top: 20px;">
                <button id="restart-session-btn">üîÅ Luy·ªán t·∫≠p l·∫°i h·ªôi tho·∫°i n√†y</button>
                <button id="choose-new-btn" style="background-color: #6c757d;">üè† Ch·ªçn h·ªôi tho·∫°i kh√°c</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- B·∫ÆT ƒê·∫¶U PH·∫¶N T·∫¢I H·ªòI THO·∫†I T·ª™ GITHUB ---
            const owner = 'truongkhaai136-dot';
            const repo = 'webtiengduc';
            const baseFolderPath = 'hoi-thoai';
            const conversationContainer = document.getElementById('danh-sach-hoi-thoai');
            const dialogueInput = document.getElementById('dialogue-input'); 

            let fileList = [];

            function loadFileContent(downloadUrl, buttonElement) {
                document.querySelectorAll('.file-button').forEach(btn => btn.disabled = true);
                buttonElement.textContent = 'ƒêang t·∫£i...';

                fetch(downloadUrl)
                    .then(response => response.text())
                    .then(content => {
                        dialogueInput.value = content;
                        dialogueInput.focus();
                        dialogueInput.scrollTop = 0;
                        
                        buttonElement.textContent = 'ƒê√£ t·∫£i th√†nh c√¥ng!';
                        buttonElement.style.backgroundColor = '#198754';
                        
                        setTimeout(() => {
                            document.querySelectorAll('.file-button').forEach(btn => {
                                btn.disabled = false;
                                btn.textContent = btn.dataset.filename;
                                btn.style.backgroundColor = '#0d6efd';
                            });
                        }, 1500);
                    })
                    .catch(error => {
                        console.error('L·ªói khi t·∫£i n·ªôi dung file:', error);
                        buttonElement.textContent = 'T·∫£i l·ªói!';
                        buttonElement.style.backgroundColor = '#dc3545';
                    });
            }
            
            function renderFileList() {
                if (!conversationContainer) return;
                conversationContainer.innerHTML = '<h2>Ch·ªçn m·ªôt h·ªôi tho·∫°i ƒë·ªÉ b·∫Øt ƒë·∫ßu:</h2>';
                
                fileList.sort((a, b) => a.path.localeCompare(b.path));

                fileList.forEach(file => {
                    const button = document.createElement('button');
                    const prettyName = file.path
                        .replace(baseFolderPath + '/', '')
                        .replace('.txt', '')
                        .replace(/\//g, ' / ')
                        .replace(/_/g, ' ')
                        .replace(/-/g, ' ');
                    
                    button.textContent = prettyName;
                    button.dataset.filename = prettyName;
                    button.title = `T·∫£i h·ªôi tho·∫°i: ${prettyName}`;
                    button.classList.add('file-button');
                    
                    button.addEventListener('click', () => {
                        loadFileContent(file.download_url, button);
                    });
                    
                    conversationContainer.appendChild(button);
                });
            }

            async function fetchAllFiles(path) {
                const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) throw new Error(`L·ªói m·∫°ng khi truy c·∫≠p ${path}`);
                    const items = await response.json();

                    const promises = items.map(async (item) => {
                        if (item.type === 'dir') {
                            await fetchAllFiles(item.path);
                        } else if (item.type === 'file' && item.name.endsWith('.txt')) {
                            fileList.push({
                                path: item.path,
                                download_url: item.download_url
                            });
                        }
                    });

                    await Promise.all(promises);
                } catch (error) {
                    console.error(error);
                    if(conversationContainer) {
                        conversationContainer.innerHTML = `<p style="color: red;">L·ªói: Kh√¥ng th·ªÉ t·∫£i danh s√°ch h·ªôi tho·∫°i t·ª´ GitHub.</p>`;
                    }
                }
            }

            if (conversationContainer && dialogueInput) {
                fetchAllFiles(baseFolderPath).then(() => {
                    renderFileList();
                });
            }
            // --- K·∫æT TH√öC PH·∫¶N T·∫¢I H·ªòI THO·∫†I ---


            // --- B·∫ÆT ƒê·∫¶U PH·∫¶N LUY·ªÜN N√ìI C·ª¶A B·∫†N ---
            // --- 1. L·∫•y c√°c ph·∫ßn t·ª≠ HTML ---
            const loadBtn = document.getElementById('load-btn');
            const swapRolesBtn = document.getElementById('swap-roles-btn');
            const toggleBtn = document.getElementById('toggle-line-btn');
            const recordBtn = document.getElementById('record-btn');
            const practiceArea = document.getElementById('practice-area');
            const computerLine = document.getElementById('computer-line');
            const userLine = document.getElementById('user-line');
            const userLineTitle = document.getElementById('user-line-title');
            const statusArea = document.getElementById('status-area');
            const initialSetup = document.getElementById('initial-setup');
            const sessionControlsArea = document.getElementById('session-controls-area');
            const reviewArea = document.getElementById('review-area');
            const reviewContent = document.getElementById('review-content');
            const restartSessionBtn = document.getElementById('restart-session-btn');
            const chooseNewBtn = document.getElementById('choose-new-btn');
            const rewardsInput = document.getElementById('rewards-input');
            const penaltiesInput = document.getElementById('penalties-input');
            const scoreArea = document.getElementById('score-area');
            const successAudioInput = document.getElementById('success-audio');
            const failureAudioInput = document.getElementById('failure-audio');

            // --- 2. Kh·ªüi t·∫°o Web API & Bi·∫øn tr·∫°ng th√°i ---
            const synthesis = window.speechSynthesis;
            let voices = [];
            let linesA = [], linesB = [];
            let currentLineIndex = 0;
            let userIsB = true;
            let isUserLineVisible = false;
            let score = 100;
            let isRecording = false;
            let successAudioURL = null;
            let failureAudioURL = null;
            let currentFailureAudio = null;
            
            // ** NEW **: Bi·∫øn ƒë·ªÉ qu·∫£n l√Ω c·ª≠a s·ªï popup
            let translatePopup;

            if (!synthesis) {
                statusArea.textContent = "L·ªói: Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Web Speech Synthesis API.";
                [loadBtn, swapRolesBtn, toggleBtn, recordBtn].forEach(b => b.disabled = true);
            }

            function loadVoices() { voices = synthesis.getVoices(); }
            loadVoices();
            if (synthesis.onvoiceschanged !== undefined) { synthesis.onvoiceschanged = loadVoices; }

            // --- 3. C√°c h√†m ch·ª©c nƒÉng ---
            function speak(text, onEndCallback) {
                if (synthesis.speaking) { synthesis.cancel(); }
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.voice = voices.find(voice => voice.name === 'Microsoft Amala Online (Natural) - German (Germany)') || voices.find(voice => voice.lang === 'de-DE');
                utterance.onend = () => onEndCallback && onEndCallback();
                synthesis.speak(utterance);
            }

            function playAudioPromise(url) {
                return new Promise((resolve, reject) => {
                    if (!url) { resolve(); return; }
                    const audio = new Audio(url);
                    audio.onended = resolve;
                    audio.onerror = reject;
                    audio.play();
                });
            }

            function lcs(seq1, seq2) {
                const m = seq1.length, n = seq2.length;
                const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
                for (let i = 1; i <= m; i++) {
                    for (let j = 1; j <= n; j++) {
                        if (seq1[i - 1] === seq2[j - 1]) {
                            dp[i][j] = dp[i - 1][j - 1] + 1;
                        } else {
                            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                        }
                    }
                }
                let i = m, j = n;
                const result = [];
                while (i > 0 && j > 0) {
                    if (seq1[i - 1] === seq2[j - 1]) {
                        result.unshift(seq1[i - 1]);
                        i--; j--;
                    } else if (dp[i - 1][j] > dp[i][j - 1]) { i--; } 
                    else { j--; }
                }
                return result;
            }

            function createDiffHtml(originalText, spokenText) {
                const clean = (text) => text.toLowerCase().replace(/[^\w\s'√§√∂√º√ü]/g, "").split(/\s+/).filter(Boolean);
                const originalWords = clean(originalText);
                const spokenWords = clean(spokenText);
                const commonSubsequence = new Set(lcs(originalWords, spokenWords));
                let correctWords = 0;
                const spokenHtml = spokenWords.map(word => {
                    if (commonSubsequence.has(word)) {
                        correctWords++;
                        return `<span class="diff-correct">${word}</span>`;
                    } else {
                        return `<span class="diff-incorrect">${word}</span>`;
                    }
                }).join(' ');
                const originalHtml = originalWords.map(word => {
                    if (commonSubsequence.has(word)) {
                        return `<span class="diff-correct">${word}</span>`;
                    } else {
                        return `<span class="diff-missing">${word}</span>`;
                    }
                }).join(' ');
                const accuracy = originalWords.length > 0 ? Math.round((correctWords / originalWords.length) * 100) : 0;
                return {
                    html: `<div><strong>C√¢u tho·∫°i g·ªëc:</strong> ${originalHtml}</div><div><strong>B·∫°n ƒë√£ n√≥i:</strong> ${spokenHtml}</div>`,
                    accuracy: accuracy
                };
            }

            function updateDialogueDisplay() {
                const computerRole = userIsB ? 'A' : 'B';
                const userRole = userIsB ? 'B' : 'A';
                const computerText = userIsB ? linesA[currentLineIndex] : linesB[currentLineIndex];
                const userText = userIsB ? linesB[currentLineIndex] : linesA[currentLineIndex];
                computerLine.textContent = `${computerRole} (M√°y): ${computerText || '...'}`;
                userLine.textContent = userText || '...';
                userLineTitle.textContent = `C√¢u c·ªßa b·∫°n (${userRole}):`;
                userLine.style.display = isUserLineVisible ? 'block' : 'none';
                toggleBtn.textContent = isUserLineVisible ? 'üôâ ·∫®n L·ªùi Tho·∫°i' : 'üôà Hi·ªán L·ªùi Tho·∫°i';
                swapRolesBtn.textContent = `üîÅ ƒê·ªïi Vai (Hi·ªán t·∫°i: B·∫°n l√† ${userRole})`;
            }

            function startPractice() {
                currentLineIndex = 0;
                score = 100;
                updateScoreDisplay();
                statusArea.innerHTML = '';
                statusArea.className = 'status';
                initialSetup.style.display = 'none';
                reviewArea.style.display = 'none';
                practiceArea.style.display = 'block';
                sessionControlsArea.style.display = 'block';
                [toggleBtn].forEach(b => b.disabled = false);
                updateDialogueDisplay();
                recordBtn.disabled = true;
                recordBtn.textContent = '...';

                if (userIsB) {
                    if(linesA[0]) speak(linesA[0], handleNextTurn); else handleNextTurn();
                } else {
                    statusArea.textContent = 'ƒê·∫øn l∆∞·ª£t b·∫°n (Vai A).';
                    computerLine.textContent = `B (M√°y): ...ch·ªù b·∫°n n√≥i...`;
                    handleNextTurn();
                }
            }
            
            function showReview() {
                practiceArea.style.display = 'none';
                sessionControlsArea.style.display = 'none';
                if (score >= 80) {
                    const rewardMsg = getRandomItem(rewardsInput.value) || "Ch√∫c m·ª´ng!";
                    statusArea.innerHTML = `üéâ ${rewardMsg} B·∫°n ƒë√£ ho√†n th√†nh v·ªõi s·ªë ƒëi·ªÉm ${score}!`;
                    statusArea.className = 'status success';
                } else {
                    const penaltyMsg = getRandomItem(penaltiesInput.value) || "C·ªë g·∫Øng h∆°n nh√©!";
                    statusArea.innerHTML = `ü§î ${penaltyMsg} B·∫°n ch·ªâ ƒë·∫°t ${score} ƒëi·ªÉm. Luy·ªán t·∫≠p th√™m nh√©!`;
                    statusArea.className = 'status error';
                }
                reviewArea.style.display = 'block';
                reviewContent.innerHTML = 'Ph·∫ßn xem l·∫°i b·∫£n ghi √¢m ƒë√£ ƒë∆∞·ª£c lo·∫°i b·ªè v√¨ kh√¥ng c√≤n s·ª≠ d·ª•ng microphone tr·ª±c ti·∫øp.';
            }

            function updateScoreDisplay() { scoreArea.textContent = `ƒêi·ªÉm: ${score}`; }
            function getRandomItem(list) {
                const items = list.split('\n').filter(item => item.trim() !== '');
                if (items.length === 0) return '';
                return items[Math.floor(Math.random() * items.length)];
            }
            
            // --- 4. G·∫Øn c√°c s·ª± ki·ªán ---
            loadBtn.addEventListener('click', () => {
                const fullText = dialogueInput.value.trim(); if (fullText === '') { alert('Vui l√≤ng nh·∫≠p ƒëo·∫°n h·ªôi tho·∫°i!'); return; }
                const lines = fullText.split('\n').filter(line => line.trim() !== ''); linesA = []; linesB = [];
                lines.forEach(line => {
                    if (line.toLowerCase().startsWith('a:')) linesA.push(line.substring(2).trim());
                    else if (line.toLowerCase().startsWith('b:')) linesB.push(line.substring(2).trim());
                });
                if (linesA.length === 0 && linesB.length === 0) { alert('L·ªói: Kh√¥ng t√¨m th·∫•y c√¢u tho·∫°i n√†o h·ª£p l·ªá (b·∫Øt ƒë·∫ßu b·∫±ng "A:" ho·∫∑c "B:")'); return; }
                startPractice();
            });

            swapRolesBtn.addEventListener('click', () => { 
                userIsB = !userIsB; 
                if (linesA.length > 0 || linesB.length > 0) { startPractice(); } 
                else { updateDialogueDisplay(); } 
            });

            toggleBtn.addEventListener('click', () => { 
                isUserLineVisible = !isUserLineVisible; 
                userLine.style.display = isUserLineVisible ? 'block' : 'none'; 
                toggleBtn.textContent = isUserLineVisible ? 'üôâ ·∫®n L·ªùi Tho·∫°i' : 'üôà Hi·ªán L·ªùi Tho·∫°i'; 
            });

            // --- ** NEW & REWRITTEN ** ---
            function startRecording() {
                if (isRecording) return;
                isRecording = true;

                recordBtn.disabled = true;
                recordBtn.textContent = 'üî¥ ƒêang ch·ªù...';
                statusArea.innerHTML = 'C·ª≠a s·ªï Google D·ªãch s·∫Ω m·ªü. <br>H√£y nh·∫•n v√†o micro üéôÔ∏è v√† n√≥i, sau ƒë√≥ nh·∫•n l·∫°i ƒë·ªÉ k·∫øt th√∫c.';
                statusArea.className = 'status';

                const googleTranslateURL = `https://translate.google.com/?sl=de&tl=vi&op=translate`;
                
                // M·ªü popup
                translatePopup = window.open(googleTranslateURL, 'GoogleTranslatePopup', 'width=600,height=700');

                // Script ƒë·ªÉ inject v√†o popup
                const injectionScript = `
                    // Script n√†y s·∫Ω ch·∫°y trong popup c·ªßa Google D·ªãch
                    // N√≥ s·∫Ω theo d√µi thay ƒë·ªïi trong √¥ vƒÉn b·∫£n ngu·ªìn (ti·∫øng ƒê·ª©c)
                    // v√† g·ª≠i l·∫°i k·∫øt qu·∫£ v·ªÅ cho c·ª≠a s·ªï ch√≠nh.
                    const sourceTextAreaSelector = 'textarea[aria-label="VƒÉn b·∫£n ngu·ªìn"]';
                    let lastValue = '';
                    
                    // L·∫Øng nghe s·ª± ki·ªán click tr√™n n√∫t micro
                    // Khi ng∆∞·ªùi d√πng click micro l·∫ßn th·ª© 2 (ƒë·ªÉ d·ª´ng), ta l·∫•y k·∫øt qu·∫£
                     const micButtonSelector = 'button[aria-label="D·ªãch b·∫±ng gi·ªçng n√≥i"]';
                     let micButton = null;

                    const observer = new MutationObserver(mutations => {
                        const sourceTextArea = document.querySelector(sourceTextAreaSelector);
                        if (sourceTextArea && sourceTextArea.value && sourceTextArea.value !== lastValue) {
                            lastValue = sourceTextArea.value;
                            // Ch·ªâ g·ª≠i message khi c√≥ k·∫øt qu·∫£ cu·ªëi c√πng
                             if (micButton && micButton.getAttribute('data-is-listening') === 'false') {
                                window.opener.postMessage({
                                    type: 'transcript',
                                    transcript: lastValue
                                }, '*'); // G·ª≠i v·ªÅ c·ª≠a s·ªï ƒë√£ m·ªü n√≥
                             }
                        }
                    });

                    // B·∫Øt ƒë·∫ßu theo d√µi khi trang ƒë√£ t·∫£i xong
                    const intervalId = setInterval(() => {
                        const targetNode = document.querySelector(sourceTextAreaSelector);
                        micButton = document.querySelector(micButtonSelector);
                        
                        if (targetNode && micButton) {
                            clearInterval(intervalId);
                            // B·∫Øt ƒë·∫ßu theo d√µi
                            observer.observe(targetNode, { attributes: true, childList: true, subtree: true, characterData: true });
                            
                             micButton.addEventListener('click', () => {
                                 // H∆°i delay m·ªôt ch√∫t ƒë·ªÉ Google c·∫≠p nh·∫≠t tr·∫°ng th√°i
                                setTimeout(() => {
                                    const isListening = micButton.getAttribute('data-is-listening') === 'true';
                                    if (!isListening && lastValue) {
                                         window.opener.postMessage({
                                            type: 'transcript',
                                            transcript: lastValue
                                        }, '*');
                                    }
                                }, 200);
                             });
                        }
                    }, 500);
                `;

                // V·∫•n ƒë·ªÅ: Kh√¥ng th·ªÉ inject script tr·ª±c ti·∫øp v√¨ cross-origin.
                // Gi·∫£i ph√°p: Ng∆∞·ªùi d√πng s·∫Ω t·ª± n√≥i v√† popup s·∫Ω g·ª≠i k·∫øt qu·∫£ v·ªÅ.
                // Ta ch·ªâ c·∫ßn l·∫Øng nghe message. ƒêo·∫°n code tr√™n ch·ªâ l√† √Ω t∆∞·ªüng.
                // Ng∆∞·ªùi d√πng c·∫ßn t∆∞∆°ng t√°c v·ªõi popup, khi c√≥ k·∫øt qu·∫£, ch√∫ng ta x·ª≠ l√Ω.
            }
            
            // L·∫Øng nghe tin nh·∫Øn t·ª´ popup
            window.addEventListener('message', (event) => {
                // Th√™m ki·ªÉm tra ngu·ªìn g·ªëc ƒë·ªÉ b·∫£o m·∫≠t
                // if (event.origin !== "https://translate.google.com") return;

                if (event.data && event.data.type === 'transcript') {
                    const spokenText = event.data.transcript;
                    
                    // ƒê√≥ng popup
                    if (translatePopup && !translatePopup.closed) {
                        translatePopup.close();
                    }
                    translatePopup = null;
                    isRecording = false;
                    
                    if (spokenText) {
                        processFinalResult(spokenText);
                    } else {
                        recordBtn.disabled = false;
                        recordBtn.textContent = 'üé§ Th·ª≠ L·∫°i';
                        statusArea.textContent = "Kh√¥ng nh·∫≠n ƒë∆∞·ª£c k·∫øt qu·∫£. Vui l√≤ng th·ª≠ l·∫°i.";
                        statusArea.className = 'status error';
                    }
                }
            }, false);

            recordBtn.addEventListener('click', startRecording);
            
            function handleNextTurn() {
                const userText = userIsB ? linesB[currentLineIndex] : linesA[currentLineIndex];
                if (userText) {
                    statusArea.textContent = 'ƒê·∫øn l∆∞·ª£t b·∫°n. H√£y nh·∫•n n√∫t ƒë·ªÉ ghi √¢m.';
                    recordBtn.disabled = false;
                    recordBtn.textContent = 'üé§ B·∫Øt ƒê·∫ßu Ghi √Çm';
                } else {
                    currentLineIndex++;
                    const conversationLength = Math.max(linesA.length, linesB.length);
                    if (currentLineIndex >= conversationLength) {
                        setTimeout(showReview, 1000);
                        return;
                    }
                    const nextLineToSpeak = userIsB ? linesA[currentLineIndex] : linesB[currentLineIndex];
                    if (nextLineToSpeak) {
                        speak(nextLineToSpeak, handleNextTurn);
                    } else {
                        setTimeout(showReview, 1000);
                    }
                }
            }
            
            async function processFinalResult(spokenText) {
                if (!spokenText) return;
                
                const targetText = userIsB ? linesB[currentLineIndex] : linesA[currentLineIndex];
                const difficultyThreshold = parseInt(document.querySelector('input[name="difficulty"]:checked').value);
                const { html: diffHtml, accuracy } = createDiffHtml(targetText, spokenText.trim());

                if (accuracy >= difficultyThreshold) {
                    statusArea.className = 'status success';
                    const rewardMsg = getRandomItem(rewardsInput.value);
                    statusArea.innerHTML = `${rewardMsg} (ƒê·ªô ch√≠nh x√°c: ${accuracy}%)`;
                    await playAudioPromise(successAudioURL);
                    currentLineIndex++;
                    const conversationLength = Math.max(linesA.length, linesB.length);
                    if (currentLineIndex >= conversationLength) {
                        setTimeout(showReview, 1000);
                        return;
                    }
                    updateDialogueDisplay();
                    const nextLineToSpeak = userIsB ? linesA[currentLineIndex] : (linesB[currentLineIndex] || null);
                    if (nextLineToSpeak) {
                        statusArea.textContent = 'M√°y ƒëang n√≥i...';
                        recordBtn.disabled = true;
                        recordBtn.textContent = '...';
                        const speakPromise = new Promise(resolve => speak(nextLineToSpeak, resolve));
                        await speakPromise;
                        handleNextTurn();
                    } else {
                        handleNextTurn();
                    }
                } else {
                    statusArea.className = 'status error';
                    score -= 5;
                    updateScoreDisplay();
                    const penaltyMsg = getRandomItem(penaltiesInput.value);
                    statusArea.innerHTML = `<div style="margin-bottom: 10px;">${penaltyMsg} (${accuracy}%). Th·ª≠ l·∫°i nh√©! (-5 ƒëi·ªÉm)</div><div class="feedback-box">${diffHtml}</div>`;
                    if (failureAudioURL) {
                        if (currentFailureAudio) { currentFailureAudio.pause(); }
                        currentFailureAudio = new Audio(failureAudioURL);
                        currentFailureAudio.play();
                        currentFailureAudio.onended = () => { currentFailureAudio = null; };
                    }
                    recordBtn.disabled = false;
                    recordBtn.textContent = 'üé§ Th·ª≠ L·∫°i';
                }
            }
            
            // S·ª∞ KI·ªÜN CHO C√ÅC N√öT M·ªöI
            restartSessionBtn.addEventListener('click', () => {
                startPractice();
            });

            chooseNewBtn.addEventListener('click', () => {
                reviewArea.style.display = 'none'; 
                initialSetup.style.display = 'block'; 
                practiceArea.style.display = 'none'; 
                sessionControlsArea.style.display = 'none'; 
                statusArea.innerHTML = ''; 
                statusArea.className = 'status';
                dialogueInput.value = ''; 
                linesA = []; linesB = []; currentLineIndex = 0; 
                score = 100;
                updateScoreDisplay();
                if (conversationContainer) {
                    conversationContainer.style.display = 'block';
                }
            });

            successAudioInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    if (successAudioURL) URL.revokeObjectURL(successAudioURL);
                    successAudioURL = URL.createObjectURL(file);
                }
            });

            failureAudioInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    if (failureAudioURL) URL.revokeObjectURL(failureAudioURL);
                    failureAudioURL = URL.createObjectURL(file);
                }
            });

            // ** NEW ** H∆∞·ªõng d·∫´n cho ng∆∞·ªùi d√πng v·ªÅ vi·ªác g·ª≠i transcript
            const infoScript = document.createElement('script');
            infoScript.innerHTML = `
                // ƒê√¢y l√† ƒëo·∫°n code b·∫°n c·∫ßn ch·∫°y trong CONSOLE c·ªßa popup Google D·ªãch
                // ƒë·ªÉ n√≥ c√≥ th·ªÉ g·ª≠i k·∫øt qu·∫£ v·ªÅ trang luy·ªán t·∫≠p.
                function setupTranscriptSender() {
                    const sourceTextAreaSelector = 'textarea[aria-label="VƒÉn b·∫£n ngu·ªìn"], textarea[aria-label="Source text"]';
                    const micButtonSelector = 'button[data-is-listening]';
                    let lastValue = '';
                    let observer;

                    const intervalId = setInterval(() => {
                        const targetNode = document.querySelector(sourceTextAreaSelector);
                        const micButton = document.querySelector(micButtonSelector);
                        
                        if (targetNode && micButton) {
                            clearInterval(intervalId);
                            console.log("ƒê√£ t√¨m th·∫•y c√°c th√†nh ph·∫ßn. S·∫µn s√†ng g·ª≠i transcript.");
                            
                            observer = new MutationObserver(mutations => {
                                const isListening = micButton.getAttribute('data-is-listening') === 'true';
                                if (!isListening && targetNode.value && targetNode.value !== lastValue) {
                                    lastValue = targetNode.value;
                                    console.log('Ph√°t hi·ªán transcript:', lastValue);
                                    window.opener.postMessage({
                                        type: 'transcript',
                                        transcript: lastValue
                                    }, '*'); 
                                }
                            });

                            observer.observe(targetNode, { attributes: true, childList: true, subtree: true, characterData: true });
                        }
                    }, 1000);
                }
                // B·∫°n c√≥ th·ªÉ sao ch√©p h√†m setupTranscriptSender() v√† d√°n v√†o console c·ªßa popup.
            `;
            document.body.appendChild(infoScript);
            console.log("ƒê·ªÉ popup Google D·ªãch t·ª± ƒë·ªông g·ª≠i k·∫øt qu·∫£ v·ªÅ, h√£y m·ªü Console (F12) trong popup ƒë√≥ v√† d√°n ƒëo·∫°n m√£ sau: setupTranscriptSender()");

        });
    </script>
</body>
</html>
